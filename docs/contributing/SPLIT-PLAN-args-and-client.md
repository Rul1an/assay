# Split Plan: >800 LOC Files (Feb 2026)

Prioritized refactor of the largest handwritten files. Best practices: module-per-domain, <800 LOC/file (means, not goal), explicit re-exports, minimal import churn.

---

## 0. Inventory gate (source of truth)

**Inventory is always derived from HEAD.** Do not rely on copied lists in this doc.

**Generate fresh inventory:**

```bash
./scripts/largest_rust_files.sh
# Or: rg --files crates | xargs wc -l | awk '$1 >= 800' (exclude total)
```

Include inventory output (or `largest_rust_files.sh` output) in the PR description when opening a split PR.

**Rule:** If a file appears in inventory but a split was already mentioned/completed elsewhere (e.g. "writer.rs → manifest/limits/verify/write.rs"): **STOP and reconcile** — stale report or branch mismatch. Do not refactor the wrong file or re-split an already-split module.

---

## 1. Completed

| File | Was | Status |
|------|-----|--------|
| assay-cli args | 1262 LOC | ✅ Split into `args/` (mod, common, run, baseline, bundle, policy, …) |
| assay-registry client | 1273 LOC | ✅ Split into `client/` (mod, http, helpers). See [SPLIT-CHECKLIST-registry-client.md](SPLIT-CHECKLIST-registry-client.md) |

---

## 2. Current >800 LOC inventory (reference)

*Generated by `./scripts/largest_rust_files.sh` on HEAD. Verify before each split.*

| LOC | Path (from crates/) | Crate |
|-----|---------------------|-------|
| 1442 | `assay-evidence/src/bundle/writer.rs` | assay-evidence |
| 1155 | `assay-registry/src/canonicalize.rs` | assay-registry |
| 1065 | `assay-registry/src/verify.rs` | assay-registry |
| 1057 | `assay-core/src/explain.rs` | assay-core |
| 1046 | `assay-core/src/runtime/mandate_store.rs` | assay-core |
| 1042 | `assay-core/src/engine/runner.rs` | assay-core |
| 970 | `assay-evidence/src/json_strict.rs` | assay-evidence |
| 936 | `assay-core/tests/parity.rs` | assay-core |
| 881 | `assay-core/src/providers/trace.rs` | assay-core |
| 863 | `assay-registry/src/lockfile.rs` | assay-registry |
| 844 | `assay-registry/src/cache.rs` | assay-registry |
| 833 | `assay-cli/src/cli/commands/monitor.rs` | assay-cli |
| 816 | `assay-cli/tests/contract_exit_codes.rs` | assay-cli |

*Excluded: `assay-ebpf/src/vmlinux.rs` (auto-generated)*

---

## 3. Best practices (per split)

### 3A. Leak-free contracts

Per target file, define a mini-contract:

- **Where may X live?** (e.g. status mapping only in http.rs)
- **Where may X not live?** (e.g. mod.rs must not know status codes)

Add **grep-gates** (like [SPLIT-CHECKLIST-registry-client.md](SPLIT-CHECKLIST-registry-client.md)):

```bash
rg "forbidden_pattern" path/to/module/mod.rs
# Expect: 0 matches
```

### 3B. Behavior freeze tests (before split)

For each >800 LOC production file: **one contract/integration test suite** that locks current behavior *before* splitting.

Prevents: "it compiles, but semantics drift."

### 3C. LOC is a means, not a goal

Some files may stay ~850 LOC if they are one coherent domain and splitting would be artificial. What matters: **module boundaries that make behavior locateable** (e.g. status mapping in one place).

### 3D. Grep-gates robustness (avoid false positives)

Numeric literals (`401`, `404`, `429`) can appear in comments/docs. Prefer patterns that match code:

```bash
# Prefer (matches code only):
rg -n "StatusCode::|\.status\(\)|\.as_u16\(\)" crates/assay-registry/src/client/mod.rs
# Expect: 0

# Avoid (matches comments too):
rg -n "401|404|429" ...
```

### 3E. CI: no-default-features gate (during split)

Per crate that you split, add one CI job to catch ungated imports:

```yaml
# Example: assay-cli with sim as default feature
- run: cargo build -p assay-cli --no-default-features
# Or: cargo test -p assay-registry --no-default-features
```

Catches "accidentally un-gated import" regressions.

---

## 4. Next priorities (with split designs)

### 4.1 json_strict.rs (~970) — quick win

**Theme:** Strict JSON parsing + error reporting.

**Target structure:**

```
json_strict/
  mod.rs          # public API: validate_json_strict(...)
  scan.rs         # lexer-ish scanning, unicode/surrogate rules
  dupkeys.rs      # duplicate key detection
  errors.rs       # error types, codes, formatting
tests/
  json_strict_accept.rs   # data-driven: fixtures/accept/*.json
  json_strict_reject.rs   # data-driven: fixtures/reject/*.json + expected ErrorCode
```

**Gates:**

- Corpus tests: data-driven `fixtures/accept/*.json` and `fixtures/reject/*.json` (100–200 small strings)
- Determinism: same input always yields same ErrorCode (no HashMap iteration order dependence)
- Fuzz gate (optional): crash-free; deterministic errors (no panics)

---

### 4.2 canonicalize.rs (1155) — high ROI

**Theme:** Parsing, normalization, digesting, validation.

**Target structure:**

```
canonicalize/
  mod.rs          # façade: canonicalize_pack(...), canonicalize_bytes(...)
  yaml.rs         # YAML parsing/normalization
  json.rs         # JCS/RFC8785 helpers (if present)
  digest.rs       # sha256 / digest derivations
  validate.rs     # structural constraints / error codes
  errors.rs       # CanonicalizeError, CanonicalizeCode
  tests.rs or tests/  # integration tests
```

**Leak-free contract:**

| mod.rs | yaml.rs | digest.rs | validate.rs |
|--------|---------|-----------|-------------|
| No serde_yaml, Value, Sha256, hex | May serde_yaml, Value, sorting | May sha2, hex | May pack invariants |
| No reqwest, fs | No reqwest, fs | No serde_yaml, jcs | No IO |

**Forbidden grep (mod.rs):**

```bash
rg "serde_yaml|Yaml|Value|Sha256|hex::|sha2::|Digest|canonical_yaml|sort_|BTreeMap::new\(" crates/assay-registry/src/canonicalize/mod.rs
# Expect: 0
```

**Public API:** Expose both consumers explicitly: `canonicalize_bytes(...)` (for signing) and digest (for metadata). Test both paths.

**Merge gates:**

- Golden digest parity: input pack fixtures → digest exact
- Stability: whitespace/key order variants → same digest
- Failure codes stable: invalid pack → CanonicalizeCode unchanged

**Move map:** See [Appendix A: canonicalize move map](#appendix-a-canonicalize-move-map).

---

### 4.3 verify.rs (1065) — high ROI

**Theme:** Trust chain, signature verification, key fetch.

**Target structure:**

```
verify/
  mod.rs          # public API: verify_pack(...), verify_signature(...)
  digest.rs       # digest parsing + compare rules
  dsse.rs         # DSSE envelope parse/verify
  keys.rs         # key selection / trust roots / key id matching
  policy.rs       # trust policy decisions (what is accepted)
  errors.rs       # VerifyError, reason codes
```

**Leak-free contract:**

| mod.rs | dsse.rs | policy.rs |
|--------|---------|-----------|
| No ed25519, rsa, sha2, base64, serde_json | May crypto, base64, serde_json | May policy rules |
| No reqwest, fs | No policy (unsigned_allowed, etc.) | No crypto types |

**Policy purity:** `policy.rs` must not import crypto types. Let `dsse.rs` normalize algorithm to a string/enum (e.g. `SignatureAlg`) that policy can match without crypto crates.

**Forbidden grep (mod.rs):**

```bash
rg "ed25519|rsa|sha2|hex::|Signature|PublicKey|serde_json::from_str\(|base64" crates/assay-registry/src/verify/mod.rs
# Expect: 0
rg "reqwest|tokio|std::fs" crates/assay-registry/src/verify/mod.rs
# Expect: 0
```

**Merge gates:**

- Mismatch digest → fail-closed
- Missing signature when required → fail-closed
- Unsigned pack allowed path → exact current behavior
- Invalid DSSE shape → stable VerifyCode
- Trust root mismatch → stable VerifyCode

**Move map:** See [Appendix B: verify move map](#appendix-b-verify-move-map).

---

### 4.4 runner.rs (1042) — medium/high ROI

**Theme:** Orchestration + scheduling + IO + formatting.

**Target structure:**

```
engine/runner/
  mod.rs          # Runner entrypoints
  plan.rs         # build execution plan, resolve suites
  execute.rs      # execute steps (pure-ish)
  report.rs       # result aggregation, emit summary
  limits.rs       # time budgets, iteration budgets
  errors.rs
```

**Leak-free contract:**

| plan.rs | execute.rs | report.rs | limits.rs |
|---------|------------|-----------|-----------|
| No IO | No formatting | No execution | Time/timeout only |
| Config → plan | Steps → raw results | Results → summaries | Single source for infra vs fail |

**Ordering rule:** Document explicitly in `plan.rs`: "plan.rs sorts steps by &lt;criteria&gt;" (deterministic ordering).

**Infra vs policy fail:** Only `limits.rs` decides "infra_error" triggers (timeouts, cancellations). Only `report.rs` maps outcomes → exit codes.

**Forbidden grep:**

```bash
rg -n "std::fs|tokio::fs|reqwest|Write|File|println!|eprintln!" crates/assay-core/src/engine/runner/plan.rs
rg -n "serde_json|to_string_pretty|jcs|println!|eprintln!" crates/assay-core/src/engine/runner/execute.rs
rg -n "tokio::time::sleep|timeout|select!|spawn|JoinHandle" crates/assay-core/src/engine/runner/report.rs
# Expect: 0 for each
```

**Merge gates:**

- Determinism: same seed/config → same ordering & result set
- Exit code contract preserved

**Move map:** See [Appendix C: runner move map](#appendix-c-runner-move-map).

---

### 4.5 mandate_store.rs (1046)

**Target structure:**

```
runtime/mandate_store/
  mod.rs
  store.rs        # persistence layer
  query.rs        # filtering, indexing
  types.rs        # mandate structs
  validate.rs     # invariants
```

**Gates:** Roundtrip write→read invariants; concurrency/locking semantics if relevant.

---

### 4.6 explain.rs (1057)

**Target structure:**

```
explain/
  mod.rs          # explain(rule_id, context) -> ExplainDoc
  catalog.rs      # rule catalog & lookups
  render_text.rs
  render_json.rs
  render_md.rs    # if Markdown output exists
  helpers.rs
```

**Gates:** Explain IDs stable; "missing explanation" fallback behavior stable.

---

### 4.7 trace.rs (881)

**Target structure:**

```
providers/trace/
  mod.rs
  parse.rs
  replay.rs
  mappers.rs
```

---

### 4.8 bundle/writer.rs (1442)

**Target structure:** TBD — confirm on HEAD before split. If `writer.rs` was already split (e.g. to manifest/limits/verify/write.rs), reconcile inventory first per §0.

---

### 4.9 Test files (parity.rs, contract_exit_codes.rs)

Lower priority; do after "hot" production code. Split per `tests/<topic>/mod.rs` + `cases_*.rs`.

---

## 5. Implementation order (recommended)

| Step | Task |
|------|------|
| 1 | `json_strict.rs` — quick win, isolated |
| 2 | `canonicalize.rs` — contract-heavy, good to freeze |
| 3 | `verify.rs` — builds on canonicalize/digest |
| 4 | `runner.rs` |
| 5 | `mandate_store.rs` |
| 6 | `explain.rs` |
| 7 | `trace.rs` |
| 8 | `bundle/writer.rs` |
| 9 | Test files (parity.rs, contract_exit_codes.rs) |

---

## 6. PR checklist template (per split)

Per split PR, require:

- [ ] **API paths unchanged** — re-export façade; existing `use crate::...` works
- [ ] **No import churn** — consumers unchanged
- [ ] **Behavior freeze tests exist** — or moved, not removed
- [ ] **No double responsibility** — e.g. retry only in http.rs
- [ ] **Grep-gates for forbidden knowledge** — status codes, IO, etc. per module
- [ ] `cargo test -p <crate>` passes
- [ ] `cargo clippy -p <crate> --all-targets -- -D warnings` passes

**Copy-paste acceptance block (paste into PR description):**

```bash
# Required
cargo test -p <crate>
cargo clippy -p <crate> --all-targets -- -D warnings

# Forbidden-knowledge gates (per split design)
rg "<pattern>" crates/<crate>/src/<module>/mod.rs  # expect 0

# API path smoke check
rg "pub use" crates/<crate>/src/<facade_mod>.rs
```

**Minimal review artifacts for PR description:**

- List of new modules + "what lives where"
- Forbidden grep patterns + results (0 matches where expected)
- Which behavior freeze tests exist / were added
- Confirmation "public API unchanged"

---

## 7. Mechanical execution (per split)

For each of the top-3 splits:

1. Create directory + `mod.rs` façade (empty functions with `todo!()` if needed)
2. Move blocks 1:1 (cut/paste); compile after each module
3. Fix imports (only after moves)
4. Add forbidden grep gates locally (ideally as CI step later)
5. Run `cargo test -p <crate>` + `cargo clippy -p <crate> --all-targets -- -D warnings`
6. Add 1–3 behavior freeze tests if missing

---

## 8. References

- `scripts/largest_rust_files.sh` — generate >800 LOC inventory on HEAD
- CONTRIBUTING.md § File size guideline
- CLAUDE.md: CLI entry points, assay-cli structure
- [SPLIT-CHECKLIST-registry-client.md](SPLIT-CHECKLIST-registry-client.md) — PR checklist for client split

---

## Appendix A: canonicalize move map

**Doelstructuur:** `crates/assay-registry/src/canonicalize/` (mod, yaml, json, digest, validate, errors)

**Leak-free contract:**

- mod.rs: geen parsing details (geen serde_yaml), geen hashing internals, alleen orchestration
- yaml.rs: enige plek met YAML parsing/format decisions
- digest.rs: enige plek met Sha256, hex, sha256: prefix logic
- validate.rs: enige plek met pack shape invariants en policy checks

**Move map:**

| Module | Contents |
|--------|----------|
| **mod.rs** | `pub fn canonicalize_pack(...)`, `canonicalize_bytes(...)` (als bestaat), `pub use errors::{CanonicalizeError, CanonicalizeCode}`. Orchestratie: 1) parse → yaml::parse_pack 2) validate → validate::validate_pack 3) canonical bytes → yaml::emit_canonical_yaml (of json::to_jcs_vec) 4) digest → digest::sha256_prefixed |
| **yaml.rs** | `parse_pack_yaml()`, `normalize_yaml_value()`, `emit_canonical_yaml()`, serde_yaml::from_*, Value, mapping/sequence ordering, sort keys, strip comments |
| **json.rs** | `to_jcs_bytes()`, stable key order helpers (als JCS aanwezig; anders adapter/re-exports) |
| **digest.rs** | `compute_digest()`, `normalize_digest_str()`, sha256: prefix, Sha256, hex |
| **validate.rs** | required fields, schema_version, allowed keys, rule id formats, referential integrity |
| **errors.rs** | `CanonicalizeError`, `CanonicalizeCode`, `From<serde_yaml::Error>` |

**Forbidden grep patterns:**

```bash
# mod.rs — expect 0
rg -n "serde_yaml|Yaml|Value|Sha256|hex::|sha2::|Digest|canonical_yaml|sort_|BTreeMap::new\(" crates/assay-registry/src/canonicalize/mod.rs

# yaml.rs — expect 0 (no IO)
rg -n "reqwest|tokio::fs|std::fs|Url|StatusCode" crates/assay-registry/src/canonicalize/yaml.rs

# digest.rs — expect 0 (no YAML/JCS)
rg -n "serde_yaml|jcs|rfc8785" crates/assay-registry/src/canonicalize/digest.rs
```

**Merge gates:** Golden digest parity; stability (whitespace/key order → same digest); failure codes stable.

---

## Appendix B: verify move map

**Doelstructuur:** `crates/assay-registry/src/verify/` (mod, digest, dsse, keys, policy, errors)

**Leak-free contract:**

- mod.rs: geen cryptolib details, geen file/network IO
- dsse.rs: enige plek DSSE envelope parse + verify
- keys.rs: enige plek key lookup/selection logic
- policy.rs: enige plek "unsigned allowed?" / "what algorithms allowed?"

**Move map:**

| Module | Contents |
|--------|----------|
| **mod.rs** | `verify_pack()`, `verify_signature()` (als bestaat). Orchestratie: 1) digest::expected_digest 2) dsse::parse_envelope 3) keys::resolve_key 4) dsse::verify_envelope 5) policy::evaluate |
| **digest.rs** | digest parsing, header vs computed comparison, coupling to canonicalize (via façade) |
| **dsse.rs** | DSSE envelope parse, signature verify (ed25519/rsa), payload type, predicate type |
| **keys.rs** | trust roots, key id matching (header vs DSSE), "select correct public key" |
| **policy.rs** | unsigned_allowed?, required claims present?, allowed algorithm set |
| **errors.rs** | `VerifyCode`, `VerifyError { code, message, source }` |

**Forbidden grep patterns:**

```bash
# mod.rs — expect 0
rg -n "ed25519|rsa|sha2|hex::|Signature|PublicKey|serde_json::from_str\(|base64" crates/assay-registry/src/verify/mod.rs
rg -n "reqwest|tokio|std::fs" crates/assay-registry/src/verify/mod.rs

# dsse.rs — expect 0 (no policy)
rg -n "unsigned_allowed|allowed_alg" crates/assay-registry/src/verify/dsse.rs

# policy.rs — expect 0 (no crypto)
rg -n "ed25519|rsa|verify\(|PublicKey|Signature" crates/assay-registry/src/verify/policy.rs
```

**Merge gates:** mismatch digest → fail-closed; missing signature when required → fail-closed; unsigned pack allowed path exact; invalid DSSE shape → stable VerifyCode; trust root mismatch → stable VerifyCode.

---

## Appendix C: runner move map

**Doelstructuur:** `crates/assay-core/src/engine/runner/` (mod, plan, execute, limits, report, errors)

**Leak-free contract:**

- plan.rs: geen IO, alleen config → plan
- execute.rs: geen formatting, alleen execute steps → raw results
- report.rs: geen execution, alleen results → summaries/artifacts
- limits.rs: enige plek met time budgeting/timeout decisions

**Move map:**

| Module | Contents |
|--------|----------|
| **mod.rs** | `Runner`, `run_suite()`. Wiring: plan::build_plan → execute::run_plan → report::build_report |
| **plan.rs** | `ExecutionPlan`, `build_plan()`, selection logic (suite → steps), ordering (deterministic) |
| **execute.rs** | `run_plan(plan, deps, limits) -> Vec<StepOutcome>`, step loop, no printing (except trace) |
| **limits.rs** | `RunLimits`, time_budget, per_step_timeout, enforce(), infra vs fail |
| **report.rs** | `RunnerReport`, `StepSummary`, `AggregateMetrics`, JSON output (no file IO), outcomes → exit code |
| **errors.rs** | `RunnerCode`, `RunnerError { code, message, source }` |

**Forbidden grep patterns:**

```bash
# plan.rs — expect 0
rg -n "std::fs|tokio::fs|reqwest|Write|File|println!|eprintln!" crates/assay-core/src/engine/runner/plan.rs

# execute.rs — expect 0
rg -n "serde_json|to_string_pretty|jcs|println!|eprintln!" crates/assay-core/src/engine/runner/execute.rs

# report.rs — expect 0
rg -n "tokio::time::sleep|timeout|select!|spawn|JoinHandle" crates/assay-core/src/engine/runner/report.rs
```

**Merge gates:** Determinism (same seed/config → same ordering & result set); exit code contract preserved.
