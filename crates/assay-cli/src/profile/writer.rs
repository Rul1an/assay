use super::suggest::PolicySuggestion;
use std::fs::File;
use std::io::Write;
use std::path::Path;

/// Write policy suggestion to YAML string (deterministic).
pub fn write_yaml(s: &PolicySuggestion) -> String {
    let mut out = String::new();
    out.push_str("# Generated by `assay sandbox --profile`\n");
    out.push_str("api_version: 1\n");

    out.push_str("extends:\n");
    for e in &s.extends {
        out.push_str(&format!("  - {}\n", e));
    }

    out.push_str("fs:\n");
    out.push_str("  allow:\n");
    for p in &s.fs_allow {
        out.push_str(&format!("    - \"{}\"\n", escape(p)));
    }
    out.push_str("  deny:\n");
    for p in &s.fs_deny {
        out.push_str(&format!("    - \"{}\"\n", escape(p)));
    }

    out.push_str("net:\n");
    out.push_str("  allow: []\n");
    out.push_str("  deny:\n");
    out.push_str("    - \"*:*\"\n");

    out.push_str("env:\n");
    out.push_str("  allow:\n");
    for k in &s.env_allow {
        out.push_str(&format!("    - \"{}\"\n", escape(k)));
    }

    out.push_str("processes:\n");
    out.push_str("  allow:\n");
    for x in &s.exec_allow {
        out.push_str(&format!("    - \"{}\"\n", escape(x)));
    }

    out.push_str("meta:\n");
    out.push_str("  counters:\n");
    for (k, v) in &s.counters {
        out.push_str(&format!("    \"{}\": {}\n", escape(k), v));
    }

    if !s.notes.is_empty() {
        out.push_str("  notes:\n");
        for n in &s.notes {
            out.push_str(&format!("    - \"{}\"\n", escape(n)));
        }
    }

    out
}

fn escape(s: &str) -> String {
    s.replace('\\', "\\\\").replace('"', "\\\"")
}

/// Save content to disk atomically and safely.
pub fn save_atomic(path: &Path, content: &str) -> anyhow::Result<()> {
    // 1. Check if target is a symlink (avoid TOCTOU/symlink attacks if possible)
    if path.exists() {
        let meta = std::fs::symlink_metadata(path)?;
        if meta.file_type().is_symlink() {
            anyhow::bail!("Refusing to write to symlink: {}", path.display());
        }
    }

    let temp_path = path.with_extension("tmp");

    // 2. Create temp file
    let mut file = File::create(&temp_path)?;

    // 3. Set permissions 0600 (Unix)
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let mut perms = file.metadata()?.permissions();
        perms.set_mode(0o600);
        file.set_permissions(perms)?;
    }

    // 4. Write content
    file.write_all(content.as_bytes())?;

    // 5. Fsync
    file.sync_all()?;
    drop(file); // Ensure closed

    // 6. Rename
    std::fs::rename(&temp_path, path)?;

    Ok(())
}
