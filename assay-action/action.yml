# Assay GitHub Action v2.1
# Verify, lint, and diff evidence bundles from AI agent runs.
# v2.1 adds: Compliance packs, BYOS push with OIDC, artifact attestation, coverage badges.
#
# Spec: https://github.com/Rul1an/assay/blob/main/docs/architecture/SPEC-GitHub-Action-v2.1.md
# ADR:  https://github.com/Rul1an/assay/blob/main/docs/architecture/ADR-018-GitHub-Action-v2.1.md
# Marketplace: https://github.com/marketplace/actions/assay-ai-agent-security
#
# Usage (zero-config):
#   - uses: Rul1an/assay/assay-action@v2
#
# Usage (with compliance pack):
#   - uses: Rul1an/assay/assay-action@v2
#     with:
#       pack: eu-ai-act-baseline
#       sarif: true
#
# Usage (with BYOS push + attestation):
#   - uses: Rul1an/assay/assay-action@v2
#     with:
#       store: s3://my-bucket/evidence
#       store_role: arn:aws:iam::123456789012:role/AssayEvidence
#       attest: true
#
# Usage (with coverage badge):
#   - uses: Rul1an/assay/assay-action@v2
#     with:
#       badge_gist: abc123def456
#       badge_token: ${{ secrets.GIST_TOKEN }}

name: 'Assay - AI Agent Security'
description: 'Verify and lint AI agent evidence bundles. Catch security issues before production. Native GitHub Security tab integration.'
author: 'Assay Contributors'

branding:
  icon: 'shield'
  color: 'blue'

inputs:
  bundles:
    description: 'Glob pattern for evidence bundles'
    required: false
    default: ''
  fail_on:
    description: 'Fail threshold: error, warn, info, none'
    required: false
    default: 'error'
  sarif:
    description: 'Upload SARIF to GitHub Security tab'
    required: false
    default: 'true'
  category:
    description: 'SARIF category (auto-generated if omitted)'
    required: false
    default: ''
  baseline_dir:
    description: 'Path to baseline bundles for diff'
    required: false
    default: ''
  baseline_key:
    description: 'Key for baseline cache lookup'
    required: false
    default: ''
  write_baseline:
    description: 'Write baseline after successful run (main branch only)'
    required: false
    default: 'false'
  comment_diff:
    description: 'Post PR comment with diff summary'
    required: false
    default: 'true'
  upload_artifacts:
    description: 'Deprecated. Use reports_dir output instead.'
    required: false
    default: 'false'
  version:
    description: 'Assay CLI version to install'
    required: false
    default: 'latest'

  # ============ New (v2.1) ============
  pack:
    description: |
      Compliance pack(s) to apply (comma-separated).
      Examples: eu-ai-act-baseline, soc2-baseline, ./custom.yaml
    required: false
    default: ''
  store:
    description: |
      BYOS store URL for evidence push.
      Examples: s3://bucket/prefix, az://container, gs://bucket
      Requires OIDC trust relationship configured.
    required: false
    default: ''
  store_provider:
    description: |
      Cloud provider for OIDC authentication.
      Options: aws, gcp, azure, auto (detect from URL)
    required: false
    default: 'auto'
  store_role:
    description: |
      IAM role/identity for OIDC authentication.
      AWS: arn:aws:iam::ACCOUNT:role/ROLE
      GCP: projects/PROJECT/locations/global/workloadIdentityPools/POOL/providers/PROVIDER
    required: false
    default: ''
  store_region:
    description: 'AWS region (AWS only)'
    required: false
    default: 'us-east-1'
  azure_client_id:
    description: 'Azure App Registration client ID (required for azure)'
    required: false
    default: ''
  azure_tenant_id:
    description: 'Azure AD tenant ID (required for azure)'
    required: false
    default: ''
  azure_subscription_id:
    description: 'Azure subscription ID (required for azure)'
    required: false
    default: ''
  attest:
    description: |
      Generate SLSA-aligned artifact attestation for evidence bundles.
      Requires permissions: attestations: write, id-token: write
      Only runs on push to default branch.
    required: false
    default: 'false'
  badge_gist:
    description: |
      Gist ID for dynamic coverage badge.
      Only runs on push to default branch.
    required: false
    default: ''
  badge_token:
    description: |
      GitHub PAT for badge gist update.
      Requires gist scope. Pass via secrets.GIST_TOKEN.
      Only used when badge_gist is set.
    required: false
    default: ''

outputs:
  verified:
    description: 'true if all bundles passed verification'
    value: ${{ steps.process.outputs.verified }}
  findings_error:
    description: 'Count of error-level findings'
    value: ${{ steps.process.outputs.findings_error }}
  findings_warn:
    description: 'Count of warning-level findings'
    value: ${{ steps.process.outputs.findings_warn }}
  sarif_path:
    description: 'Path to generated SARIF file'
    value: ${{ steps.process.outputs.sarif_path }}
  sarif_uploaded:
    description: 'true if SARIF was successfully uploaded to Code Scanning'
    value: ${{ steps.sarif-status.outputs.uploaded || 'false' }}
  diff_summary:
    description: 'One-line diff summary'
    value: ${{ steps.process.outputs.diff_summary }}
  diff_new_findings:
    description: 'Count of new findings vs baseline'
    value: ${{ steps.baseline-diff.outputs.new_findings || '0' }}
  reports_dir:
    description: 'Path to reports directory (for artifact upload)'
    value: ${{ steps.process.outputs.reports_dir }}

  # ============ New (v2.1) ============
  pack_applied:
    description: 'Comma-separated list of applied pack IDs'
    value: ${{ steps.pack-lint.outputs.pack_applied }}
  pack_score:
    description: 'Compliance score (0-100) across all packs'
    value: ${{ steps.pack-lint.outputs.pack_score }}
  pack_articles:
    description: 'Comma-separated list of covered articles (e.g., "12(1),12(2)(a)")'
    value: ${{ steps.pack-lint.outputs.pack_articles }}
  bundle_url:
    description: 'URL of pushed evidence bundle in BYOS (if store set)'
    value: ${{ steps.byos-push.outputs.bundle_url }}
  attestation_id:
    description: 'Artifact attestation UUID (if attest=true)'
    value: ${{ steps.export-attestation.outputs.attestation_id }}
  attestation_url:
    description: 'URL to view attestation in GitHub UI (if attest=true)'
    value: ${{ steps.export-attestation.outputs.attestation_url }}
  attestation_bundle_path:
    description: 'Local path to Sigstore bundle file'
    value: ${{ steps.export-attestation.outputs.attestation_bundle_path }}
  coverage_percent:
    description: 'Evidence coverage percentage (tools with policy / total tools)'
    value: ${{ steps.coverage.outputs.coverage_percent }}

runs:
  using: 'composite'
  steps:
    # =========================================================================
    # E1: Foundation - Platform detection, caching, binary installation
    # =========================================================================

    - name: Check if Assay already in PATH
      id: check-existing
      shell: bash
      run: |
        if command -v assay &> /dev/null; then
          echo "Assay already installed: $(assay --version)"
          echo "skip_install=true" >> $GITHUB_OUTPUT
        else
          echo "skip_install=false" >> $GITHUB_OUTPUT
        fi

    - name: Detect platform
      id: platform
      if: steps.check-existing.outputs.skip_install != 'true'
      shell: bash
      run: |
        OS=$(uname -s | tr '[:upper:]' '[:lower:]')
        ARCH=$(uname -m)

        case "$ARCH" in
          x86_64)         ARCH="x86_64" ;;
          aarch64|arm64)  ARCH="aarch64" ;;
          *)
            echo "::error::Unsupported architecture: $ARCH"
            exit 1
            ;;
        esac

        case "$OS" in
          linux)  TARGET="${ARCH}-unknown-linux-gnu" ;;
          darwin) TARGET="${ARCH}-apple-darwin" ;;
          *)
            echo "::error::Unsupported OS: $OS"
            exit 1
            ;;
        esac

        echo "target=$TARGET" >> $GITHUB_OUTPUT
        echo "os=$OS" >> $GITHUB_OUTPUT
        echo "arch=$ARCH" >> $GITHUB_OUTPUT

    - name: Restore cached binary
      id: cache
      if: steps.check-existing.outputs.skip_install != 'true'
      uses: actions/cache@0c907a75c2c80ebcb7f088228285e798b750cf8f # v4.2.1
      with:
        path: ~/.assay/bin
        key: assay-${{ inputs.version }}-${{ steps.platform.outputs.target }}

    - name: Install Assay CLI
      if: steps.check-existing.outputs.skip_install != 'true' && steps.cache.outputs.cache-hit != 'true'
      shell: bash
      env:
        ASSAY_VERSION: ${{ inputs.version }}
        ASSAY_TARGET: ${{ steps.platform.outputs.target }}
      run: |
        set -euo pipefail
        mkdir -p ~/.assay/bin

        VERSION="$ASSAY_VERSION"
        TARGET="$ASSAY_TARGET"
        REPO="Rul1an/assay"

        # Resolve 'latest' to actual version
        if [ "$VERSION" = "latest" ]; then
          VERSION=$(curl -fsSL "https://api.github.com/repos/$REPO/releases/latest" | grep '"tag_name"' | cut -d'"' -f4)
          if [ -z "$VERSION" ]; then
            echo "::error::Failed to fetch latest version"
            exit 1
          fi
        fi

        DOWNLOAD_URL="https://github.com/$REPO/releases/download/${VERSION}/assay-${VERSION}-${TARGET}.tar.gz"
        echo "Downloading Assay ${VERSION} for ${TARGET}..."

        if ! curl -fsSL "$DOWNLOAD_URL" | tar xz -C ~/.assay/bin; then
          echo "::error::Failed to download Assay from $DOWNLOAD_URL"
          exit 1
        fi

        chmod +x ~/.assay/bin/assay
        echo "✓ Installed Assay ${VERSION}"

    - name: Add to PATH and verify
      id: verify-install
      if: steps.check-existing.outputs.skip_install != 'true'
      shell: bash
      run: |
        echo "$HOME/.assay/bin" >> $GITHUB_PATH
        export PATH="$HOME/.assay/bin:$PATH"

        if ! ~/.assay/bin/assay --version; then
          echo "::error::Assay installation verification failed"
          exit 1
        fi

        echo "installed=true" >> $GITHUB_OUTPUT

    # =========================================================================
    # E2: Evidence Processing - Discovery, verify, lint
    # (Placeholder - will be implemented in Epic 2)
    # =========================================================================

    - name: Discover evidence bundles
      id: discover
      shell: bash
      env:
        BUNDLES_PATTERN: ${{ inputs.bundles }}
        RUNNER_TEMP: ${{ runner.temp }}
      run: |
        set -euo pipefail

        # Use RUNNER_TEMP for cross-platform compatibility (Windows support)
        TEMP_DIR="${RUNNER_TEMP:-/tmp}"

        # Auto-discover if no pattern provided
        if [ -z "$BUNDLES_PATTERN" ]; then
          # Use find with explicit paths (safer than glob expansion)
          BUNDLES=$(find . \( -path './.assay/evidence/*.tar.gz' -o -path './evidence/*.tar.gz' \) -type f 2>/dev/null | head -100 || true)
        else
          # Glob expansion: use compgen for safe pattern matching
          # shellcheck disable=SC2086
          if compgen -G "$BUNDLES_PATTERN" > /dev/null 2>&1; then
            BUNDLES=$(compgen -G "$BUNDLES_PATTERN" | head -100)
          else
            BUNDLES=""
          fi
        fi

        if [ -z "$BUNDLES" ]; then
          echo "::notice::No evidence bundles found. Run 'assay run' to generate them."
          echo "found=false" >> $GITHUB_OUTPUT
          echo "count=0" >> $GITHUB_OUTPUT
          exit 0
        fi

        COUNT=$(echo "$BUNDLES" | wc -l | tr -d ' ')
        echo "Found $COUNT evidence bundle(s)"
        echo "$BUNDLES"

        # Save to file for later steps (use RUNNER_TEMP for Windows compat)
        echo "$BUNDLES" > "$TEMP_DIR/assay-bundles.txt"
        echo "bundles_file=$TEMP_DIR/assay-bundles.txt" >> $GITHUB_OUTPUT
        echo "found=true" >> $GITHUB_OUTPUT
        echo "count=$COUNT" >> $GITHUB_OUTPUT

    - name: Process bundles (verify + lint)
      id: process
      if: steps.discover.outputs.found == 'true'
      shell: bash
      env:
        FAIL_ON: ${{ inputs.fail_on }}
        BUNDLES_FILE: ${{ steps.discover.outputs.bundles_file }}
        RUNNER_TEMP: ${{ runner.temp }}
      run: |
        set -euo pipefail
        export PATH="$HOME/.assay/bin:$PATH"

        REPORTS_DIR="${GITHUB_WORKSPACE}/.assay-reports"
        mkdir -p "$REPORTS_DIR"
        echo "reports_dir=$REPORTS_DIR" >> $GITHUB_OUTPUT

        TEMP_DIR="${RUNNER_TEMP:-/tmp}"
        BUNDLES=$(cat "$BUNDLES_FILE")

        # Verify all bundles
        VERIFIED=0
        FAILED=0
        for bundle in $BUNDLES; do
          if assay evidence verify "$bundle" 2>/dev/null; then
            ((VERIFIED++)) || true
          else
            ((FAILED++)) || true
            echo "::error file=$bundle::Bundle verification failed"
          fi
        done

        echo "verified_count=$VERIFIED" >> $GITHUB_OUTPUT
        echo "failed_count=$FAILED" >> $GITHUB_OUTPUT

        if [ "$FAILED" -gt 0 ]; then
          echo "verified=false" >> $GITHUB_OUTPUT
          exit 2  # Distinct exit code for verification failure
        fi
        echo "verified=true" >> $GITHUB_OUTPUT

        # Lint all bundles (one at a time, aggregate results)
        TOTAL_ERRORS=0
        TOTAL_WARNS=0
        echo '{"findings":[]}' > "$REPORTS_DIR/lint.json"

        for bundle in $BUNDLES; do
          echo "Linting: $bundle"

          # Lint to JSON for counting
          LINT_JSON=$(assay evidence lint --format json "$bundle" 2>/dev/null || echo '{"findings":[]}')

          # Count findings in this bundle
          BUNDLE_ERRORS=$(echo "$LINT_JSON" | jq '[.findings // [] | .[] | select(.severity == "error")] | length' 2>/dev/null || echo "0")
          BUNDLE_WARNS=$(echo "$LINT_JSON" | jq '[.findings // [] | .[] | select(.severity == "warning")] | length' 2>/dev/null || echo "0")

          TOTAL_ERRORS=$((TOTAL_ERRORS + BUNDLE_ERRORS))
          TOTAL_WARNS=$((TOTAL_WARNS + BUNDLE_WARNS))

          # Append findings to aggregate
          echo "$LINT_JSON" | jq '.findings // []' >> "$TEMP_DIR/all-findings.json" 2>/dev/null || true

          # Generate SARIF for this bundle
          assay evidence lint --format sarif "$bundle" > "$REPORTS_DIR/lint-$(basename "$bundle" .tar.gz).sarif" 2>/dev/null || true
        done

        # Merge SARIF files if multiple
        FIRST_SARIF=$(ls "$REPORTS_DIR"/*.sarif 2>/dev/null | head -1)
        if [ -n "$FIRST_SARIF" ]; then
          cp "$FIRST_SARIF" "$REPORTS_DIR/lint.sarif"
        fi

        echo "sarif_path=$REPORTS_DIR/lint.sarif" >> $GITHUB_OUTPUT

        ERRORS=$TOTAL_ERRORS
        WARNS=$TOTAL_WARNS

        echo "findings_error=$ERRORS" >> $GITHUB_OUTPUT
        echo "findings_warn=$WARNS" >> $GITHUB_OUTPUT

        # Apply fail_on threshold
        case "$FAIL_ON" in
          error)
            if [ "$ERRORS" -gt 0 ]; then
              echo "::error::$ERRORS error-level findings exceed threshold"
              exit 1
            fi
            ;;
          warn)
            if [ "$ERRORS" -gt 0 ] || [ "$WARNS" -gt 0 ]; then
              echo "::error::$ERRORS errors, $WARNS warnings exceed threshold"
              exit 1
            fi
            ;;
          info)
            # Fail on any finding (info not yet implemented, treat as warn)
            if [ "$ERRORS" -gt 0 ] || [ "$WARNS" -gt 0 ]; then
              exit 1
            fi
            ;;
          none)
            # Never fail on findings
            ;;
        esac

        echo "diff_summary=Verified: $VERIFIED, Errors: $ERRORS, Warnings: $WARNS" >> $GITHUB_OUTPUT

    # =========================================================================
    # E3: SARIF Upload
    # =========================================================================

    - name: Generate SARIF category
      id: sarif-category
      if: inputs.sarif == 'true' && steps.discover.outputs.found == 'true'
      shell: bash
      env:
        USER_CATEGORY: ${{ inputs.category }}
        RUNNER_OS: ${{ runner.os }}
      run: |
        if [ -n "$USER_CATEGORY" ]; then
          echo "category=$USER_CATEGORY" >> $GITHUB_OUTPUT
        else
          # Auto-generate unique category per job + OS (matrix-safe)
          # Include runner.os to prevent collisions in matrix builds
          CATEGORY="assay-${{ github.workflow }}-${{ github.job }}-${RUNNER_OS}"
          echo "category=$CATEGORY" >> $GITHUB_OUTPUT
        fi

    - name: Upload SARIF to GitHub Security
      id: upload-sarif
      # Gate on same-repo context: skip fork PRs where permissions are unavailable
      if: |
        inputs.sarif == 'true' &&
        steps.discover.outputs.found == 'true' &&
        (github.event_name != 'pull_request' || github.event.pull_request.head.repo.full_name == github.repository)
      # Pin to SHA for supply-chain security (verified: v4.32.0, 2026-01-26)
      uses: github/codeql-action/upload-sarif@b20883b0cd1f46c72ae0ba6d1090936928f9fa30 # v4.32.0
      with:
        sarif_file: ${{ github.workspace }}/.assay-reports/lint.sarif
        category: ${{ steps.sarif-category.outputs.category }}

    - name: Check SARIF upload status
      id: sarif-status
      if: inputs.sarif == 'true' && steps.discover.outputs.found == 'true'
      shell: bash
      env:
        UPLOAD_OUTCOME: ${{ steps.upload-sarif.outcome }}
        IS_FORK_PR: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name != github.repository }}
      run: |
        if [ "$UPLOAD_OUTCOME" = "success" ]; then
          echo "uploaded=true" >> $GITHUB_OUTPUT
          echo "SARIF uploaded successfully to GitHub Code Scanning"
        elif [ "$IS_FORK_PR" = "true" ]; then
          echo "uploaded=false" >> $GITHUB_OUTPUT
          echo "::notice::SARIF upload skipped for fork PR (no security-events:write permission). Results are available in artifacts."
        else
          echo "uploaded=false" >> $GITHUB_OUTPUT
          echo "::warning::SARIF upload failed. Check that 'security-events: write' permission is set. Results are available in artifacts."
        fi

    # =========================================================================
    # E4: PR Feedback - Job Summary + PR Comment
    # =========================================================================

    - name: Write Job Summary
      if: always()
      shell: bash
      env:
        FOUND: ${{ steps.discover.outputs.found }}
        COUNT: ${{ steps.discover.outputs.count }}
        VERIFIED: ${{ steps.process.outputs.verified }}
        VERIFIED_COUNT: ${{ steps.process.outputs.verified_count }}
        FAILED_COUNT: ${{ steps.process.outputs.failed_count }}
        ERRORS: ${{ steps.process.outputs.findings_error }}
        WARNS: ${{ steps.process.outputs.findings_warn }}
        SARIF_UPLOADED: ${{ steps.sarif-status.outputs.uploaded }}
        SARIF_ENABLED: ${{ inputs.sarif }}
        NEW_FINDINGS: ${{ steps.baseline-diff.outputs.new_findings }}
        BASELINE_FOUND: ${{ steps.baseline-diff.outputs.baseline_found }}
      run: |
        {
          echo "## Assay Evidence Report"
          echo ""

          if [ "$FOUND" != "true" ]; then
            echo "### No Evidence Bundles Found"
            echo ""
            echo "To generate evidence bundles, run your tests with Assay:"
            echo ""
            echo "\`\`\`bash"
            echo "assay run --policy policy.yaml -- pytest"
            echo "\`\`\`"
            echo ""
            echo "Bundles will be created in \`.assay/evidence/\`"
          else
            # Status badge
            if [ "$VERIFIED" = "true" ] && [ "${ERRORS:-0}" = "0" ]; then
              echo "**Status:** Passed"
            else
              echo "**Status:** Failed"
            fi
            echo ""

            echo "| Metric | Value |"
            echo "|--------|-------|"
            echo "| Bundles processed | $COUNT |"
            echo "| Verified | ${VERIFIED_COUNT:-0} |"
            if [ "${FAILED_COUNT:-0}" -gt 0 ]; then
              echo "| Verification failed | ${FAILED_COUNT} |"
            fi
            echo "| Errors | ${ERRORS:-0} |"
            echo "| Warnings | ${WARNS:-0} |"

            # Show baseline diff if available
            if [ "${BASELINE_FOUND:-false}" = "true" ]; then
              echo "| New findings (vs baseline) | ${NEW_FINDINGS:-0} |"
            fi

            # SARIF upload status
            if [ "$SARIF_ENABLED" = "true" ]; then
              if [ "${SARIF_UPLOADED:-false}" = "true" ]; then
                echo "| Code Scanning | Uploaded |"
              else
                echo "| Code Scanning | **Not uploaded** (see warning) |"
              fi
            fi

            # Show findings summary if any
            if [ "${ERRORS:-0}" -gt 0 ] || [ "${WARNS:-0}" -gt 0 ]; then
              echo ""
              echo "### Findings"
              echo ""
              if [ "${SARIF_UPLOADED:-false}" = "true" ]; then
                echo "Review findings in the **Security** tab or download the SARIF artifact."
              else
                echo "Download the **assay-reports** artifact to review findings."
              fi
            fi

            # Warning for failed SARIF upload
            if [ "$SARIF_ENABLED" = "true" ] && [ "${SARIF_UPLOADED:-false}" != "true" ]; then
              echo ""
              echo "> **Warning:** SARIF upload to Code Scanning failed."
              echo "> This is common for fork PRs (missing \`security-events: write\` permission)."
              echo "> Download the **assay-reports** artifact to review the SARIF file."
            fi
          fi

          echo ""
          echo "---"
          echo "[Assay Documentation](https://github.com/Rul1an/assay) | [Report Issue](https://github.com/Rul1an/assay/issues)"
        } >> $GITHUB_STEP_SUMMARY

    - name: Find existing PR comment
      id: find-comment
      if: github.event_name == 'pull_request' && inputs.comment_diff == 'true' && steps.discover.outputs.found == 'true'
      uses: peter-evans/find-comment@3eae4d37986fb5a8592848f6a574fdf654e61f9e # v3.1.0
      continue-on-error: true
      with:
        issue-number: ${{ github.event.pull_request.number }}
        comment-author: 'github-actions[bot]'
        body-includes: '<!-- assay-report -->'

    - name: Post or update PR comment
      if: github.event_name == 'pull_request' && inputs.comment_diff == 'true' && steps.discover.outputs.found == 'true' && (steps.process.outputs.findings_error != '0' || steps.process.outputs.findings_warn != '0')
      uses: peter-evans/create-or-update-comment@71345be0265236311c031f5c7866368bd1ebb043 # v4.0.0
      continue-on-error: true
      with:
        comment-id: ${{ steps.find-comment.outputs.comment-id }}
        issue-number: ${{ github.event.pull_request.number }}
        edit-mode: replace
        body: |
          <!-- assay-report -->
          ## Assay Report

          | Metric | Value |
          |--------|-------|
          | Bundles | ${{ steps.discover.outputs.count }} |
          | Errors | ${{ steps.process.outputs.findings_error }} |
          | Warnings | ${{ steps.process.outputs.findings_warn }} |

          View details in the [Security tab](${{ github.server_url }}/${{ github.repository }}/security/code-scanning) or [Job Summary](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}).

    # =========================================================================
    # E5: Baseline & Artifacts
    # =========================================================================

    - name: Restore baseline from cache
      id: baseline-restore
      if: inputs.baseline_key != '' && steps.discover.outputs.found == 'true'
      uses: actions/cache/restore@0c907a75c2c80ebcb7f088228285e798b750cf8f # v4.2.1
      continue-on-error: true
      with:
        path: .assay-baseline/
        key: assay-baseline-${{ inputs.baseline_key }}-${{ github.base_ref || 'main' }}
        restore-keys: |
          assay-baseline-${{ inputs.baseline_key }}-

    - name: Compare with baseline
      id: baseline-diff
      if: steps.baseline-restore.outputs.cache-hit == 'true' && steps.discover.outputs.found == 'true'
      shell: bash
      env:
        REPORTS_DIR: ${{ steps.process.outputs.reports_dir }}
      run: |
        # Fingerprint-based baseline comparison
        # Compares current findings against baseline using partialFingerprints

        if [ ! -d ".assay-baseline" ]; then
          echo "baseline_found=false" >> $GITHUB_OUTPUT
          echo "new_findings=0" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "baseline_found=true" >> $GITHUB_OUTPUT

        BASELINE_SARIF=".assay-baseline/lint.sarif"
        CURRENT_SARIF="$REPORTS_DIR/lint.sarif"

        if [ ! -f "$BASELINE_SARIF" ] || [ ! -f "$CURRENT_SARIF" ]; then
          echo "new_findings=0" >> $GITHUB_OUTPUT
          echo "::notice::Baseline or current SARIF not found, skipping diff"
          exit 0
        fi

        # Extract fingerprints from baseline
        BASELINE_FPS=$(jq -r '.runs[0].results // [] | .[].partialFingerprints["assayLintFingerprint/v1"] // empty' "$BASELINE_SARIF" 2>/dev/null | sort -u || true)

        # Extract fingerprints from current
        CURRENT_FPS=$(jq -r '.runs[0].results // [] | .[].partialFingerprints["assayLintFingerprint/v1"] // empty' "$CURRENT_SARIF" 2>/dev/null | sort -u || true)

        # Find new fingerprints (in current but not in baseline), robust to empty inputs
        if [ -z "$CURRENT_FPS" ]; then
          # No current fingerprints => no new findings
          NEW_FPS=""
          NEW_COUNT="0"
        else
          if [ -z "$BASELINE_FPS" ]; then
            # No baseline fingerprints => everything current is new
            NEW_FPS="$CURRENT_FPS"
          else
            # Both baseline and current have fingerprints: compute set difference
            NEW_FPS=$(comm -23 <(printf '%s\n' "$CURRENT_FPS") <(printf '%s\n' "$BASELINE_FPS") 2>/dev/null || true)
          fi

          if [ -z "$NEW_FPS" ]; then
            NEW_COUNT="0"
          else
            NEW_COUNT=$(printf '%s\n' "$NEW_FPS" | grep -c . 2>/dev/null || echo "0")
          fi
        fi

        echo "new_findings=$NEW_COUNT" >> $GITHUB_OUTPUT

        if [ "$NEW_COUNT" -gt 0 ]; then
          echo "::warning::$NEW_COUNT new finding(s) detected compared to baseline"

          # Write diff details to reports
          {
            echo "# Baseline Diff"
            echo ""
            echo "New findings: $NEW_COUNT"
            echo ""
            echo "## New Fingerprints"
            echo "$NEW_FPS"
          } > "$REPORTS_DIR/diff.md"
        else
          echo "No new findings vs baseline"
        fi

    - name: Prepare baseline for cache
      id: prepare-baseline
      if: |
        inputs.write_baseline == 'true' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch) &&
        steps.discover.outputs.found == 'true' &&
        steps.process.outputs.verified == 'true'
      shell: bash
      env:
        REPORTS_DIR: ${{ steps.process.outputs.reports_dir }}
      run: |
        # Copy SARIF to .assay-baseline/ to match restore path
        mkdir -p .assay-baseline
        if [ -f "$REPORTS_DIR/lint.sarif" ]; then
          cp "$REPORTS_DIR/lint.sarif" .assay-baseline/lint.sarif
        fi

    - name: Save baseline to cache
      if: steps.prepare-baseline.outcome == 'success'
      uses: actions/cache/save@0c907a75c2c80ebcb7f088228285e798b750cf8f # v4.2.1
      continue-on-error: true
      with:
        path: .assay-baseline/
        key: assay-baseline-${{ inputs.baseline_key || 'default' }}-${{ github.event.repository.default_branch }}-${{ github.sha }}

    - name: Upload reports artifact
      if: steps.discover.outputs.found == 'true'
      uses: actions/upload-artifact@65c4c4a1ddee5b72f698fdd19549f0f0fb45cf08 # v4.6.0
      continue-on-error: true
      with:
        name: assay-reports-${{ github.run_id }}
        path: ${{ steps.process.outputs.reports_dir }}
        retention-days: 30
        include-hidden-files: true

    # =========================================================================
    # v2.1: P1 - Compliance Pack Support
    # =========================================================================

    - name: Lint with compliance packs
      id: pack-lint
      if: inputs.pack != '' && steps.discover.outputs.found == 'true'
      shell: bash
      env:
        PACKS: ${{ inputs.pack }}
        BUNDLES_FILE: ${{ steps.discover.outputs.bundles_file }}
        REPORTS_DIR: ${{ steps.process.outputs.reports_dir }}
      run: |
        set -euo pipefail
        export PATH="$HOME/.assay/bin:$PATH"

        # Lint with packs (generates pack-enhanced SARIF)
        while IFS= read -r bundle || [ -n "$bundle" ]; do
          [ -z "$bundle" ] && continue
          echo "Linting with packs: $bundle"
          assay evidence lint \
            --format sarif \
            --pack "$PACKS" \
            --output "$REPORTS_DIR/pack-lint-$(basename "$bundle" .tar.gz).sarif" \
            "$bundle" || true
        done < "$BUNDLES_FILE"

        # Merge SARIF files (or copy if only one)
        SARIF_FILES=$(ls "$REPORTS_DIR"/pack-lint-*.sarif 2>/dev/null || echo "")
        if [ -z "$SARIF_FILES" ]; then
          echo "pack_applied=" >> $GITHUB_OUTPUT
          echo "pack_score=100" >> $GITHUB_OUTPUT
          echo "pack_articles=" >> $GITHUB_OUTPUT
          exit 0
        fi

        # Count SARIF files and merge if multiple
        SARIF_COUNT=$(echo "$SARIF_FILES" | wc -w | tr -d ' ')
        if [ "$SARIF_COUNT" -eq 1 ]; then
          cp $SARIF_FILES "$REPORTS_DIR/pack-lint.sarif"
        else
          # Merge all SARIF runs into single file
          jq -s '.[0] * { runs: [.[].runs[]] }' $SARIF_FILES > "$REPORTS_DIR/pack-lint.sarif" 2>/dev/null || cp $(echo $SARIF_FILES | cut -d' ' -f1) "$REPORTS_DIR/pack-lint.sarif"
        fi
        SARIF="$REPORTS_DIR/pack-lint.sarif"

        # Extract pack metadata from SARIF
        PACK_APPLIED=$(jq -r '[.runs[0].tool.driver.rules[]?.properties.pack // empty] | unique | join(",")' "$SARIF" 2>/dev/null || echo "")
        PACK_SCORE=$(jq -r '.runs[0].properties.complianceScore // 100' "$SARIF" 2>/dev/null || echo "100")
        PACK_ARTICLES=$(jq -r '[.runs[0].tool.driver.rules[]?.properties.article_ref // empty] | unique | sort | join(",")' "$SARIF" 2>/dev/null || echo "")
        DISCLAIMER=$(jq -r '.runs[0].properties.disclaimer // empty' "$SARIF" 2>/dev/null || echo "")

        echo "pack_applied=$PACK_APPLIED" >> $GITHUB_OUTPUT
        echo "pack_score=$PACK_SCORE" >> $GITHUB_OUTPUT
        echo "pack_articles=$PACK_ARTICLES" >> $GITHUB_OUTPUT

        # Store disclaimer for Job Summary (multiline safe)
        if [ -n "$DISCLAIMER" ]; then
          {
            echo "pack_disclaimer<<EOF"
            echo "$DISCLAIMER"
            echo "EOF"
          } >> $GITHUB_OUTPUT
        fi

    # =========================================================================
    # v2.1: Coverage Calculation
    # =========================================================================

    - name: Calculate evidence coverage
      id: coverage
      if: steps.discover.outputs.found == 'true'
      shell: bash
      env:
        BUNDLES_FILE: ${{ steps.discover.outputs.bundles_file }}
        RUNNER_TEMP: ${{ runner.temp }}
      run: |
        set -euo pipefail
        export PATH="$HOME/.assay/bin:$PATH"

        TEMP_DIR="${RUNNER_TEMP:-/tmp}"
        ALL_TOOLS="$TEMP_DIR/all-tools.txt"
        DECIDED_TOOLS="$TEMP_DIR/decided-tools.txt"
        > "$ALL_TOOLS"
        > "$DECIDED_TOOLS"

        # Collect unique tools across all bundles (single call per bundle)
        while IFS= read -r bundle || [ -n "$bundle" ]; do
          [ -z "$bundle" ] && continue
          STATS=$(assay evidence stats "$bundle" --json 2>/dev/null || echo '{}')
          echo "$STATS" | jq -r '.tools_observed_list // [] | .[]' >> "$ALL_TOOLS" 2>/dev/null || true
          echo "$STATS" | jq -r '.tools_with_decisions_list // [] | .[]' >> "$DECIDED_TOOLS" 2>/dev/null || true
        done < "$BUNDLES_FILE"

        # Deduplicate and count
        TOOLS_OBSERVED=$(sort -u "$ALL_TOOLS" | grep -c . 2>/dev/null || echo "0")
        TOOLS_WITH_DECISIONS=$(sort -u "$DECIDED_TOOLS" | grep -c . 2>/dev/null || echo "0")

        # Calculate coverage (floor)
        if [ "$TOOLS_OBSERVED" -gt 0 ]; then
          COVERAGE=$((TOOLS_WITH_DECISIONS * 100 / TOOLS_OBSERVED))
        else
          COVERAGE=0
        fi

        echo "coverage_percent=$COVERAGE" >> $GITHUB_OUTPUT
        echo "Coverage: $COVERAGE% ($TOOLS_WITH_DECISIONS/$TOOLS_OBSERVED tools)"

    # =========================================================================
    # v2.1: P2 - BYOS Push with OIDC
    # =========================================================================

    - name: Validate store configuration
      id: store-validate
      if: |
        inputs.store != '' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
      shell: bash
      env:
        STORE: ${{ inputs.store }}
        PROVIDER: ${{ inputs.store_provider }}
        ROLE: ${{ inputs.store_role }}
        AZURE_CLIENT_ID: ${{ inputs.azure_client_id }}
        AZURE_TENANT_ID: ${{ inputs.azure_tenant_id }}
        AZURE_SUBSCRIPTION_ID: ${{ inputs.azure_subscription_id }}
      run: |
        set -euo pipefail

        # Auto-detect provider if not set
        DETECTED_PROVIDER="$PROVIDER"
        if [ "$PROVIDER" = "auto" ]; then
          case "$STORE" in
            s3://*) DETECTED_PROVIDER="aws" ;;
            gs://*) DETECTED_PROVIDER="gcp" ;;
            az://*|https://*.blob.core.windows.net/*) DETECTED_PROVIDER="azure" ;;
            *)
              echo "::error::Unknown store URL scheme '$STORE'. Set store_provider explicitly."
              exit 3
              ;;
          esac
        fi

        # Validate required inputs per provider
        case "$DETECTED_PROVIDER" in
          aws|gcp)
            if [ -z "$ROLE" ]; then
              echo "::error::store_role is required for $DETECTED_PROVIDER OIDC authentication."
              echo "::error::AWS: arn:aws:iam::ACCOUNT:role/ROLE"
              echo "::error::GCP: projects/PROJECT/locations/global/workloadIdentityPools/POOL/providers/PROVIDER"
              exit 3
            fi
            ;;
          azure)
            if [ -z "$AZURE_CLIENT_ID" ] || [ -z "$AZURE_TENANT_ID" ] || [ -z "$AZURE_SUBSCRIPTION_ID" ]; then
              echo "::error::azure_client_id, azure_tenant_id, and azure_subscription_id are required for Azure OIDC."
              exit 3
            fi
            ;;
        esac

        echo "provider=$DETECTED_PROVIDER" >> $GITHUB_OUTPUT
        echo "Store provider: $DETECTED_PROVIDER"

    - name: Configure AWS credentials (OIDC)
      if: |
        inputs.store != '' &&
        steps.store-validate.outputs.provider == 'aws' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
      uses: aws-actions/configure-aws-credentials@e3dd6a429d7300a6a4c196c26e071d42e0343502 # v4.0.2
      with:
        role-to-assume: ${{ inputs.store_role }}
        aws-region: ${{ inputs.store_region }}

    - name: Configure GCP credentials (OIDC)
      if: |
        inputs.store != '' &&
        steps.store-validate.outputs.provider == 'gcp' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
      uses: google-github-actions/auth@6fc4af4b145ae7821d527454aa9bd537d1f2dc5f # v2.1.7
      with:
        workload_identity_provider: ${{ inputs.store_role }}

    - name: Configure Azure credentials (OIDC)
      if: |
        inputs.store != '' &&
        steps.store-validate.outputs.provider == 'azure' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
      uses: azure/login@a65d910e8af852a8061c627c456678983e180302 # v2.2.0
      with:
        client-id: ${{ inputs.azure_client_id }}
        tenant-id: ${{ inputs.azure_tenant_id }}
        subscription-id: ${{ inputs.azure_subscription_id }}

    - name: Push evidence to BYOS
      id: byos-push
      if: |
        inputs.store != '' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch) &&
        steps.process.outputs.verified == 'true'
      shell: bash
      env:
        STORE: ${{ inputs.store }}
        BUNDLES_FILE: ${{ steps.discover.outputs.bundles_file }}
      run: |
        set -euo pipefail
        export PATH="$HOME/.assay/bin:$PATH"

        BUNDLES=$(cat "$BUNDLES_FILE")
        LAST_URL=""

        for bundle in $BUNDLES; do
          echo "Pushing: $bundle -> $STORE"
          RESULT=$(assay evidence push "$bundle" --store "$STORE" --json 2>/dev/null || echo '{}')
          URL=$(echo "$RESULT" | jq -r '.url // empty')

          if [ -n "$URL" ]; then
            echo "Pushed: $URL"
            LAST_URL="$URL"
          else
            echo "::warning::Failed to push $bundle"
          fi
        done

        echo "bundle_url=$LAST_URL" >> $GITHUB_OUTPUT

    # =========================================================================
    # v2.1: P3 - Artifact Attestation
    # =========================================================================

    - name: Prepare bundles for attestation
      id: prepare-attest
      if: |
        inputs.attest == 'true' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch) &&
        steps.process.outputs.verified == 'true'
      shell: bash
      env:
        BUNDLES_FILE: ${{ steps.discover.outputs.bundles_file }}
        REPORTS_DIR: ${{ steps.process.outputs.reports_dir }}
      run: |
        # Copy evidence bundles to reports dir for attestation
        ATTEST_DIR="$REPORTS_DIR/attested-bundles"
        mkdir -p "$ATTEST_DIR"
        while IFS= read -r bundle || [ -n "$bundle" ]; do
          [ -z "$bundle" ] && continue
          cp "$bundle" "$ATTEST_DIR/"
        done < "$BUNDLES_FILE"
        echo "attest_dir=$ATTEST_DIR" >> $GITHUB_OUTPUT

    - name: Generate artifact attestation
      id: attest
      if: steps.prepare-attest.outcome == 'success'
      uses: actions/attest-build-provenance@1c608d11d69870c2092266b3f9a6f3abbf17002c # v3.0.0
      continue-on-error: true
      with:
        subject-path: ${{ steps.prepare-attest.outputs.attest_dir }}/*.tar.gz

    - name: Export attestation outputs
      id: export-attestation
      if: steps.attest.outcome == 'success'
      shell: bash
      env:
        ATTESTATION_ID: ${{ steps.attest.outputs.attestation-id }}
        ATTESTATION_URL: ${{ steps.attest.outputs.attestation-url }}
        BUNDLE_PATH: ${{ steps.attest.outputs.bundle-path }}
      run: |
        echo "attestation_id=$ATTESTATION_ID" >> $GITHUB_OUTPUT
        echo "attestation_url=$ATTESTATION_URL" >> $GITHUB_OUTPUT
        echo "attestation_bundle_path=$BUNDLE_PATH" >> $GITHUB_OUTPUT

    - name: Handle attestation unavailable
      id: attest-warn
      if: inputs.attest == 'true' && steps.attest.outcome != 'success'
      shell: bash
      run: |
        echo "::warning::Attestation skipped or failed. This may require GitHub Enterprise Cloud for private repos."
        echo "attestation_id=" >> $GITHUB_OUTPUT
        echo "attestation_url=" >> $GITHUB_OUTPUT
        echo "attestation_bundle_path=" >> $GITHUB_OUTPUT

    # =========================================================================
    # v2.1: P4 - Coverage Badge
    # =========================================================================

    - name: Update coverage badge
      if: |
        inputs.badge_gist != '' &&
        inputs.badge_token != '' &&
        github.event_name == 'push' &&
        github.ref == format('refs/heads/{0}', github.event.repository.default_branch)
      uses: schneegans/dynamic-badges-action@e9a478b16159b4d31420099ba146cdc50f134483 # v1.7.0
      continue-on-error: true
      with:
        auth: ${{ inputs.badge_token }}
        gistID: ${{ inputs.badge_gist }}
        filename: assay-coverage.json
        label: Evidence Coverage
        message: ${{ steps.coverage.outputs.coverage_percent }}%
        valColorRange: ${{ steps.coverage.outputs.coverage_percent }}
        maxColorRange: 100
        minColorRange: 0

    # =========================================================================
    # v2.1: Enhanced Job Summary
    # =========================================================================

    - name: Write v2.1 Job Summary additions
      if: always() && (inputs.pack != '' || inputs.attest == 'true')
      shell: bash
      env:
        PACK_APPLIED: ${{ steps.pack-lint.outputs.pack_applied }}
        PACK_SCORE: ${{ steps.pack-lint.outputs.pack_score }}
        PACK_ARTICLES: ${{ steps.pack-lint.outputs.pack_articles }}
        PACK_DISCLAIMER: ${{ steps.pack-lint.outputs.pack_disclaimer }}
        ATTESTATION_ID: ${{ steps.export-attestation.outputs.attestation_id }}
        ATTESTATION_URL: ${{ steps.export-attestation.outputs.attestation_url }}
        ATTEST_ENABLED: ${{ inputs.attest }}
        ATTEST_OUTCOME: ${{ steps.attest.outcome }}
        COVERAGE: ${{ steps.coverage.outputs.coverage_percent }}
        EVENT_NAME: ${{ github.event_name }}
        IS_DEFAULT_BRANCH: ${{ github.ref == format('refs/heads/{0}', github.event.repository.default_branch) }}
      run: |
        {
          # Compliance Pack Results
          if [ -n "$PACK_APPLIED" ]; then
            echo ""
            echo "## Compliance Pack Results"
            echo ""
            echo "| Pack | Score | Articles |"
            echo "|------|-------|----------|"
            echo "| $PACK_APPLIED | ${PACK_SCORE:-100}% | ${PACK_ARTICLES:-N/A} |"

            # MANDATORY: Display disclaimer if present
            if [ -n "$PACK_DISCLAIMER" ]; then
              echo ""
              echo "> ⚠️ **Disclaimer**: $PACK_DISCLAIMER"
            fi
          fi

          # Attestation section
          if [ "$ATTEST_ENABLED" = "true" ]; then
            echo ""
            echo "## Attestation"
            echo ""
            if [ -n "$ATTESTATION_ID" ]; then
              echo "| Field | Value |"
              echo "|-------|-------|"
              echo "| ID | \`$ATTESTATION_ID\` |"
              echo "| URL | [View Attestation]($ATTESTATION_URL) |"
            elif [ "$EVENT_NAME" != "push" ] || [ "$IS_DEFAULT_BRANCH" != "true" ]; then
              echo "> ℹ️ **Attestation skipped**: Only runs on push to default branch."
            elif [ "$ATTEST_OUTCOME" = "failure" ]; then
              echo "> ⚠️ **Attestation failed**: Check workflow logs for details."
            else
              echo "> ⚠️ **Attestation unavailable**: Artifact attestations require GitHub Enterprise Cloud for private repositories. [Learn more](https://docs.github.com/en/actions/security-for-github-actions/using-artifact-attestations)"
            fi
          fi

          # Coverage
          if [ -n "$COVERAGE" ]; then
            echo ""
            echo "**Evidence Coverage:** ${COVERAGE}%"
          fi
        } >> $GITHUB_STEP_SUMMARY
