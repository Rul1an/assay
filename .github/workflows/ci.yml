name: CI

on:
  push:
    branches: [ main ]
  pull_request:

jobs:
  test:
    name: Build + Test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    env:
      PYO3_USE_ABI3_FORWARD_COMPATIBILITY: 1

    steps:
      - uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Install Rust (stable)
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt, clippy

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            . -> target

      # Exclude assay-ebpf to prevent host-target mismatch errors
      - name: Build and Test Workspace
        run: |
          cargo build --workspace --exclude assay-it --exclude assay-ebpf
          cargo test --workspace --exclude assay-ity-core --exclude assay-ebpf

      - name: Test assay-cli
        run: cargo test -p assay-cli

      - name: Test assay-mcp-server
        run: cargo test -p assay-mcp-server

  ebpf-smoke:
    name: eBPF monitor smoke (Linux)
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - uses: actions/checkout@v4

      # Stable toolchain for normal workspace builds
      - uses: dtolnay/rust-toolchain@stable

      # Nightly needed because xtask builds eBPF with `cargo +nightly ... -Z build-std=core`
      - uses: dtolnay/rust-toolchain@nightly
        with:
          components: rust-src

      - name: Install system deps (llvm tools for objdump)
        run: |
          sudo apt-get update
          sudo apt-get install -y llvm clang

      - name: Build assay CLI (release)
        run: cargo build -p assay-cli --release

      - name: Build eBPF artifact (prefer Docker if available)
        run: |
          set -euxo pipefail
          # Try Docker build, fallback to local nightly
          cargo xtask build-ebpf --release --docker || cargo xtask build-ebpf --release

          # Ensure deterministic output path exists (xtask should have done this)
          if [ ! -f target/assay-ebpf.o ]; then
            echo "target/assay-ebpf.o missing; attempting fallback copy..."
            CANDIDATES=(
              "target-ebpf/bpfel-unknown-none/release/assay-ebpf"
              "target-ebpf/bpfel-unknown-none/debug/assay-ebpf"
              "target/bpfel-unknown-none/release/assay-ebpf"
            )
            for c in "${CANDIDATES[@]}"; do
              if [ -f "$c" ]; then
                mkdir -p target
                cp "$c" target/assay-ebpf.o
                break
              fi
            done
          fi

          test -f target/assay-ebpf.o
          file target/assay-ebpf.o

      - name: Verify eBPF symbols exist
        run: |
          set -euxo pipefail
          llvm-objdump -t target/assay-ebpf.o | egrep 'assay_monitor_(openat|connect)'

      - name: Ensure tracefs available (best effort)
        run: |
          set -euxo pipefail
          if [ ! -d /sys/kernel/tracing/events ]; then
            sudo mount -t tracefs nodev /sys/kernel/tracing || true
          fi
          ls /sys/kernel/tracing/events/syscalls/sys_enter_openat >/dev/null

      - name: Smoke test monitor (sudo)
        run: |
          set -euxo pipefail

          # Start a Python process that stays alive and triggers events
          # This ensures the PID we monitor is the one doing the work (TGID match)
          python3 -c "import time, os; print(f'Python PID: {os.getpid()}'); time.sleep(2); f=open('/etc/hosts'); f.close(); time.sleep(5)" &
          PID=$!
          echo "Monitoring PID=$PID"

          # Run monitor in background for 8s
          sudo ./target/release/assay monitor \
            --pid "$PID" \
            --duration 8s \
            --ebpf target/assay-ebpf.o \
            --print \
            > monitor.out 2> monitor.err &

          MON_PID=$!

          # Wait for python process to finish (approx 7s)
          wait $PID || true

          # Wait for monitor to finish duration (8s)
          wait $MON_PID || true

          echo "=== monitor.err ==="
          cat monitor.err || true
          echo "=== monitor.out ==="
          cat monitor.out || true

          # Assertions
          if grep -qiE "attach failed|failed to attach|failed to load|not supported|EPERM" monitor.err; then
             echo "Monitor failed (see monitor.err)"
             exit 1
          fi

          # Optional: Assert we saw the openat event
          # grep -q "openat" monitor.out || echo "WARNING: No openat event seen (might be unrelated)"
